<!doctype html><html lang=en><head><title>Connect 4 Solver</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><script src=https://kit.fontawesome.com/85cdec684b.js crossorigin=anonymous></script><style>@import "https://fonts.googleapis.com/css2?family=Inconsolata&display=swap";:root{--cursor-visibility:hidden}html,body{width:100%;height:100%;overflow:auto;font-family:inconsolata,monospace;font-size:4vmin;line-height:4.1vmin;font-weight:400}body{margin:0;display:flex;flex-direction:row;justify-content:center;align-items:center}#content{min-width:82vmin;min-height:82vmin}::-webkit-scrollbar{width:10px}::-webkit-scrollbar-track{border-radius:10px;box-shadow:inset 0 0 1px white}::-webkit-scrollbar-thumb{border-radius:10px;box-shadow:0 0 0 1px white}.cursor,#activity-title:after,#activity-content:after,#cd:after,#whoami:after,#cat:after,#tree:after{visibility:var(--cursor-visibility);content:"|";overflow:hidden;color:#fff;animation:blink 500ms linear infinite alternate}@keyframes blink{0%{opacity:0}100%{opacity:1}}@media only screen and (min-width:768px){body{font-size:2.5vmin;line-height:2.6vmin}#content{min-width:60vmin}}:root{--cursor-visibility:hidden}body{align-items:unset;overflow-y:scroll}#content{max-width:80vmin}pre{overflow-x:scroll;white-space:pre}@keyframes blink{0%{opacity:0}100%{opacity:1}}body{background:#2b2d42}body #terminal{color:#edf2f4}body #user{color:#ef233c}body #dir{color:#3772ff}body .Typewriter__cursor{color:#edf2f4}body #title{color:#7785ac}a{color:#edf2f4}a:hover{color:#ef233c}.navFull{background-color:#353535;font-family:courier new;font-size:17px;display:inline;position:fixed;bottom:0;left:0;width:100%;padding-top:5px;padding:10px;padding-bottom:0}.navCredits{float:right;padding-right:18px;padding-bottom:10px;padding-top:5px}#content::after{content:"\a\a";white-space:pre}</style><link rel=stylesheet href=/css/project.css><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest></head><body><div id=content><span id=activity-title></span><br><span id=activity-content></span><br><script type=text/javascript>async function typewriter(e,t,n){var s=0,o=!1;addText="";const i=document.getElementById(t),a=()=>new Promise(e=>setTimeout(e,n)),r=()=>new Promise(e=>e()),c=()=>i.innerHTML=e.slice(0,s+1)+addText,l=document.createElement("span");for(l.id="blink",i.style.setProperty("--cursor-visibility","visible");s<e.length;){if(e.charAt(s+1)==="<"&&(o=!0),e.charAt(s+1)===">"&&(o=!1),o){s++;continue}requestAnimationFrame(c),n===0?await r():await a(),s++}i.style.setProperty("--cursor-visibility","collapse")}function parseDelay(e){const t=parseInt(e,10);return isNaN(t)?0:t}const titleDelay=parseDelay("0"),contentDelay=parseDelay("0"),typeeffetct=async()=>{await typewriter("\u003cspan id=\u0027terminal\u0027\u003e\u003ch1 id=\u0027title\u0027\u003eConnect 4 Solver\u003c/h1\u003e\u003c/span\u003e","activity-title",titleDelay),await typewriter(`\u003cspan id=\u0027terminal\u0027\u003e\u003ch2 id=\u00224circle\u0022\u003e4Circle\u003c/h2\u003e
\u003cp\u003eFor the final of my Principles of Integrated Engineering class, I worked on a team of 4 to build a physical Connect 4 player that a human can play against on an actual board. I worked on the algorithm for our project, which took the current board position, and looked up to 25 moves deep into the game to find the next move.\u003c/p\u003e
\u003ch3 id=\u0022language\u0022\u003eLanguage\u003c/h3\u003e
\u003cp\u003eWe chose to write our algorithm in \u003ca href=\u0022https://go.dev\u0022\u003eGo\u003c/a\u003e, for its combination of being a very fast language as well as its relative familiarity to our team members. Other options that were considered were Python, which was ruled out as it was far too slow, and C\u002b\u002b, which we ultiamtely chose not to use to do complexity and familiarity\u003c/p\u003e
\u003ch2 id=\u0022algorithm-design\u0022\u003eAlgorithm Design\u003c/h2\u003e
\u003cp\u003eAt its core, the solving algorithm is a Negamax algorithm (a variant on Minimax that takes advantage of the fact that for turn-based, 2 player games, a player\u0026rsquo;s score for any position is the negative score of the other player) that traverses through the game tree to find the ultimate outcome of each potential move assuming both players play optimally, then plays whichever move will result in the highest final score. This is similar to how many game engines work, from Tic-Tac-Toe all the way to Chess or Go.\u003c/p\u003e
\u003cp\u003eHowever, raw Negamax is a fairly inefficient algorithm that repeats many calculations. Left to its own devices, it would take an impractically large amount of time to play a Connect 4 game. To combat this, we added many different kinds of optimizations to our Negamax algorithm until we could play a game of Connect 4 in a reasonable amount of time. Those optimizations are described below\u003c/p\u003e
\u003ch3 id=\u0022alpha-beta-pruning\u0022\u003eAlpha Beta Pruning\u003c/h3\u003e
\u003cp\u003eAlpha beta pruning is one of the classic optimizations made to the Minimax/Negamax algorithm that seeks to decrease the number of nodes explored. It does this by not exploring, or \u0026ldquo;pruning\u0026rdquo; parts of the game tree that wouldn\u0026rsquo;t have been relevant to the final path because one player already had a better move available.\u003c/p\u003e
\u003cp\u003e\u003cimg src=\u0022/pie-2022-03/4-circle/public/images/pruned.png\u0022 alt=\u0022Alpha Beta Pruning Example\u0022\u003e\u003c/p\u003e
\u003cp\u003eThis example tree shows pruned nodes in green; looking at the left side on the second level, we can see that if the blue opponent, which is seeking to minimize our score, picks its left child, we can force a score of 5. As we explore its right child, we see we can force an 8. At this point, the algorithm realizes that the blue player would never choose this right path - it is guaranteed a 5 if it goes down the other path, where as it now knows that this one will always be 8 or higher.\u003c/p\u003e
\u003cp\u003eSomething similar happens on the right with the root node - it knows choosing its left child will guarantee it a 5, and after exploring all of the non-pruned portions, it knows if it chooses the right, the blue player can force a score of -1. At this point, the remainder of the tree is relevant. The red player will never choose the right which wil result in a -1 or lower when the left guarantees at least a 5.\u003c/p\u003e
\u003ch3 id=\u0022bitboards\u0022\u003eBitboards\u003c/h3\u003e
\u003cp\u003eThe next thing we did was represent the board states using bitboards - two 64-bit integers. The first number was the position board for the current player, with a 1 where they had played to that point and a 0 where they hadn\u0026rsquo;t. The second was a board mask, which had a 1 in the spots that either player had played in, and a 0 in empty spaces.\u003c/p\u003e
\u003cp\u003eThis representation allwoed us to to things like check if a player had won, see which moves were possible, see where a player\u0026rsquo;s potential winning/losing moves could be, and even play moves onto the board with just a few binary math and shift expressions, which are very cheap for the computer to execute and take up very little memory.\u003c/p\u003e
\u003ch3 id=\u0022transposition-table-lru-cache\u0022\u003eTransposition Table (LRU Cache)\u003c/h3\u003e
\u003cp\u003eFor any given Connect 4 position, there are more than likely many different ways to reach it. However, once you are at that position, the best moves from that position are always the same, so there is no need to recalculate those moves. We took advantage of this, and implemented an LRU (\u003cstrong\u003eL\u003c/strong\u003eeast \u003cstrong\u003eR\u003c/strong\u003eecently \u003cstrong\u003eU\u003c/strong\u003esed)Cache which holds the 10 million\u003csup id=\u0022fnref:1\u0022\u003e\u003ca href=\u0022#fn:1\u0022 class=\u0022footnote-ref\u0022 role=\u0022doc-noteref\u0022\u003e1\u003c/a\u003e\u003c/sup\u003e most recently explored positions and their respective evaluations in memory. For each new position, if we find it in out cache, we can skip a large amount of computation and just take the value in our cache\u003csup id=\u0022fnref:2\u0022\u003e\u003ca href=\u0022#fn:2\u0022 class=\u0022footnote-ref\u0022 role=\u0022doc-noteref\u0022\u003e2\u003c/a\u003e\u003c/sup\u003e.\u003c/p\u003e
\u003ch3 id=\u0022anticipating-losing-moves\u0022\u003eAnticipating Losing Moves\u003c/h3\u003e
\u003cp\u003eThe next area we targeted was sniffing out potential blunders and not exploring them through Negamax at all to save a bit more time. We aimed to address these two situations:\u003c/p\u003e
\u003col\u003e
\u003cli\u003e
\u003cp\u003eIf an opponent will win by playing into a column on their next turn, we should play in that column to block their win.\u003c/p\u003e
\u003c/li\u003e
\u003cli\u003e
\u003cp\u003eIf an opponent has a winning position directly above the bottommost empty space in a column, we should not play in that column.\u003c/p\u003e
\u003c/li\u003e
\u003c/ol\u003e
\u003cp\u003eWe accomlished this using more bit-wise operations; through a series of bit shifts and comparisions, we pulled out every combination of 3 pieces that the opponent had that were one piece away from a Connect 4. Then, we checked if any could be played on the next turn (if so, then block that column!). If there were immediate blocks that needed to be made, then begin Negamax searching the rest of the columns (but exclude those that are directly below an opponent\u0026rsquo;s win position).\u003c/p\u003e
\u003ch3 id=\u0022move-ordering\u0022\u003eMove ordering\u003c/h3\u003e
\u003cp\u003eThe final big optimization we made was playing with the order we explored the nodes in. Because of the way the alpha-beta pruning works, the total number of pruned nodes increases drastically when the best moves are explored first (which means less nodes have to be explored by the algorithm). So it would follow hat we should make every effort to explore the best nodes first. But how do we know which nodes are best without actually exploring them?\u003c/p\u003e
\u003cp\u003eTo do this, we repurposed the winning position function from the losing moves section that found sets of three to instead find sets of three in our positions, and count how many there were, then ranked all 7 potential moves based on which one created the most winning opportunities. The nodes were then explored in that order.\u003c/p\u003e
\u003ch2 id=\u0022final-performance\u0022\u003eFinal Performance\u003c/h2\u003e
\u003cp\u003eBy the end of our project, we had an algorithm that could perfectly evalute positions with under 30 moves remaining in just a few seconds. For context, the board has 42 total spaces on it, and thus the longest possible game is 42 moves long. For positions that were furhter than that, they took a few minutes each, and at each move, the algorithm must evaluate 7 positions (1 for each potential column move). As an academic proof-of-concept, we had fulfilled our goal of creating an optimal solver.\u003c/p\u003e
\u003cp\u003eHowever, for demonstration purposes we felt that it was still a little too slow, so we repurposed our sets-of-three function one more time to score a position based on how many sets of three there were, and then cut off the exploration at 25 moves and returned the score of that position.\u003c/p\u003e
\u003cp\u003eWhile this did mean that the solver was no longer technically perfect, truncating it did allow us to strongly solve the game for those 25 moves (meaning it took the most efficient path towards victory instead of just any path). In practice, as soon as a win was possible within 25 moves, the algorithm would march towards it without fail, which still made it very difficult to beat.\u003c/p\u003e
\u003ch2 id=\u0022references\u0022\u003eReferences\u003c/h2\u003e
\u003cp\u003eWe took inspiration from \u003ca href=\u0022https://blog.gamesolver.org\u0022\u003ePascal Pons\u0026rsquo; project\u003c/a\u003e on solving Connect 4 when developing our algorithm, using some of its key concepts and optimizations in our Go implementation.\u003c/p\u003e
\u003cp\u003e\u003ca href=\u0022https://github.com/amit-kumarh/4circle/tree/main/algo\u0022\u003e[ PROJECT LINK HERE ]\u003c/a\u003e\u003c/p\u003e
\u003cdiv class=\u0022footnotes\u0022 role=\u0022doc-endnotes\u0022\u003e
\u003chr\u003e
\u003col\u003e
\u003cli id=\u0022fn:1\u0022\u003e
\u003cp\u003eIn testing, we found that using bigger cache sizes had a diminishining returns effect, and decided 10 million was a good balance that got us most of the performance gains without increasing memory usage too much.\u0026#160;\u003ca href=\u0022#fnref:1\u0022 class=\u0022footnote-backref\u0022 role=\u0022doc-backlink\u0022\u003e\u0026#x21a9;\u0026#xfe0e;\u003c/a\u003e\u003c/p\u003e
\u003c/li\u003e
\u003cli id=\u0022fn:2\u0022\u003e
\u003cp\u003eTechnically, nodes that are pruned by alpha-beta pruning will only give us an upper bound on the score and not the exact value, so it\u0026rsquo;s not quite as simple as just looking up a position and checking its score, but it still cuts out a huge amount of computation.\u0026#160;\u003ca href=\u0022#fnref:2\u0022 class=\u0022footnote-backref\u0022 role=\u0022doc-backlink\u0022\u003e\u0026#x21a9;\u0026#xfe0e;\u003c/a\u003e\u003c/p\u003e
\u003c/li\u003e
\u003c/ol\u003e
\u003c/div\u003e
\u003c/span\u003e`,"activity-content",contentDelay)};typeeffetct()</script></div><span class=navFull><span><a href=/>/home/amit</a>
<span>&#8192;|&#8192;</span>
<a href=/about>~/about</a>
<span>&#8192;|&#8192;</span>
<a href=/projects>~/projects</a>
<span>&#8192;|&#8192;</span>
<a href=/resume.pdf>~/resume</a></span>
<span class=navCredits>Powered by Hugo.
<a href=https://github.com/Yukuro/hugo-theme-shell style=color:#000 target=_blank rel=noopener>Theme</a></span></span></body></html>